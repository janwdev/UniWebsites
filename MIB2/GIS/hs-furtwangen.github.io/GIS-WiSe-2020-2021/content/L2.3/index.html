<!DOCTYPE html>
<html lang="en-US">


<!-- Mirrored from hs-furtwangen.github.io/GIS-WiSe-2020-2021/content/L2.3/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 04 Dec 2020 16:50:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="stylesheet" href="../../assets/css/styleb6a9.css?v=ea27abaf339b85bc83f8e9f02e46150f2ace2c25">
  <link rel="shortcut icon" type="image/x-icon" href="../../assets/faviconb6a9.ico?v=ea27abaf339b85bc83f8e9f02e46150f2ace2c25">
  <title>Grundlage interaktiver Systeme - Wintersemester 2020/2021</title>
</head>

<body>
  <header class="page-header" role="banner">
    <div class="page-header-inner main-content">
      <div class="logo-wrapper">
        <div class="logo"></div>
      </div>
      <h1 class="project-name"><a href="../../index.html">Grundlagen interaktiver Systeme</a></h1>
      <h2 class="project-tagline">für MIB und OMB – WiSe 2020/2021</h2>
      <em><a href="../index.html#1-html-und-css"><strong>1</strong> HTML und CSS</a></em>
      <em><a href="../index.html#2-typescript"><strong>2</strong> TypeScript</a></em>
      <em><a href="../index.html#3-server-und-datenbanken"><strong>3</strong> Server und Datenbanken</a></em>
    </div>
  </header>
  <main id="content" class="main-content content-wrapper" role="main">
    <h2 id="v-23-dom-manipulation-und-event-handling"><em>V</em> <strong>2.3</strong> DOM Manipulation und Event Handling</h2>

<h3 id="inhaltsverzeichnis">Inhaltsverzeichnis</h3>

<ul>
  <li><a href="#dom">DOM</a>
    <ul>
      <li><a href="#dom-manipulation">DOM Manipulation</a></li>
      <li><a href="#baumstruktur">Baumstruktur</a></li>
      <li><a href="#dom-elemente-in-ts-ansprechen">DOM Elemente in TS ansprechen</a>
        <ul>
          <li><a href="#elemente-erschaffen">Elemente erschaffen</a></li>
          <li><a href="#typassertion">Typassertion</a></li>
        </ul>
      </li>
      <li><a href="#dom-untersuchen">DOM Untersuchen</a></li>
      <li><a href="#daten-in-dom-elementen-speichern">Daten in DOM Elementen speichern</a></li>
    </ul>
  </li>
  <li><a href="#ereignisse">Ereignisse</a>
    <ul>
      <li><a href="#event-objekt">Event Objekt</a></li>
      <li><a href="#target">Target</a></li>
      <li><a href="#type">Type</a></li>
    </ul>
  </li>
  <li><a href="#event-handler">Event Handler</a>
    <ul>
      <li><a href="#handler-implementation">Handler-Implementation</a></li>
      <li><a href="#listener-installation">Listener-Installation</a></li>
    </ul>
  </li>
  <li><a href="#event-phasen">Event Phasen</a>
    <ul>
      <li><a href="#phase-1-capture">Phase 1: Capture</a></li>
      <li><a href="#phase-2-target">Phase 2: Target</a></li>
      <li><a href="#phase-3-bubble">Phase 3: Bubble</a></li>
      <li><a href="#listener-options">Listener-Options</a></li>
      <li><a href="#currenttarget">CurrentTarget</a></li>
      <li><a href="#path">Path</a></li>
    </ul>
  </li>
  <li><a href="#-fragen-und-antworten">Q&amp;A</a></li>
</ul>

<h3 id="dom">DOM</h3>
<p>Lädt der Browser eine Datei und versucht diese als HTML-Datei zu interpretieren, baut er anhand der Daten im Speicher ein <strong>Document-Object-Modell</strong> (DOM) auf. Was schließlich im Browserfenster angezeigt wird, ist also nicht ein direktes Abbild der Datei, sondern ein Abbild dieses internen Speichermodells.</p>

<p>Dabei wird aus den Elementen in der HTML Datei eine große Baumstruktur aufgebaut, bei der jeder Knoten ein Objekt ist, welcher einen Teil der Struktur repräsentiert, z.B. einen Titel, einen Absatz oder ein Bild.</p>

<p><img src="dom-tree.png" alt="DOM Baum Beispiel" /></p>

<blockquote>
  <p>Erzeugen Sie eine einfache Textdatei mit der Endung “.txt” im Dateinamen und schreiben Sie einige Worte hinein, auch mit mehreren Leerzeichenfolgen, Umlauten und Tabulatoren. Laden Sie diese Datei im Browser und schauen Sie sich in den Entwicklertools die Seitenstruktur an (Tab links neben Console)</p>
</blockquote>

<p>Es wird deutlich, dass ein <code class="language-plaintext highlighter-rouge">html</code>-Element enstanden ist und darin ein <code class="language-plaintext highlighter-rouge">head</code>-Element sowie ein <code class="language-plaintext highlighter-rouge">body</code>-Element. In letzterem ist irgendwo, wahrscheinlich in einem <code class="language-plaintext highlighter-rouge">pre</code>-Element, unser eigentlicher Text vergraben.</p>
<blockquote>
  <p>Ändern Sie die Endung in “.html” und laden Sie die Datei erneut. Was hat sich verändert?</p>
</blockquote>

<p>Ein Skript kann das DOM manipulieren, darin Elemente verändern, hinzufügen oder löschen, der Browser kümmert sich automatisch um die Darstellung für den User.</p>

<h4 id="dom-manipulation">DOM Manipulation</h4>
<video controls="" width="100%"> 
    <source src="https://lehre.gabriel-rausch.de/HFU/EIA1_static/L06/L06_05_DOM_Manipulation.mp4" type="video/mp4" /> 
    <a href="https://lehre.gabriel-rausch.de/HFU/EIA1_static/L06/L06_05_DOM_Manipulation.mp4">Zum Video</a>
</video>

<h4 id="hinweise-und-antworten-auf-potenzielle-fragen">Hinweise und Antworten auf potenzielle Fragen:</h4>

<ul>
  <li>Prof. Rausch verwendet of noch JavaScript in seinen Folien, wobei dann die typescriptspezifischen Typisierungen fehlen, welche von Ihnen ergänzt werden müssen. Meist kann VSCode vorschlagen, um welchen Typ es sich handelt. Hovern Sie dazu mit der Maus über das unterstrichene Wort.</li>
</ul>

<blockquote>
  <p><strong>Achtung:</strong> Die Begriffe Objekt, Element und Knoten können teilweise synonym verwendet werden, es ist aber Vorsicht geboten. ‘Alles’ in Javascript/TypeScript ist ein Objekt, auch etwas vom Typ <code class="language-plaintext highlighter-rouge">number</code> oder <code class="language-plaintext highlighter-rouge">string</code>. Ein Knoten ist ein Objekt mit speziellen Eigenschaften und Fähigkeiten, mit dem sich ein Graph aufbauen lässt. Ein Element wiederum ist ein spezieller Knoten, der Eigenschaften eines HTML-Elementes aufweist.</p>
</blockquote>

<p>Sehen Sie hier einen Ausschnitt aus der DOM Klassenhierarchie:</p>

<p><img src="DOM-Classhierachy.svg" alt="Schaubild" /></p>

<h4 id="baumstruktur">Baumstruktur</h4>
<p>Das DOM lässt sich als Graph mit Knoten, die mit Kanten verbunden sind, darstellen.</p>
<blockquote>
  <p>Suchen Sie die Klasse <code class="language-plaintext highlighter-rouge">Node</code> im Schaubild zur DOM-Hierarchie. Welche verwandtschaftlichen Beziehungen werden innerhalb der Klasse genutzt?</p>
</blockquote>

<p>Diese Knoten enthalten die Kernfunktionalität zur Bildung des Graphen und damit des DOMs. Jeder Knoten kann auf einen anderen Knoten als <code class="language-plaintext highlighter-rouge">parentNode</code> verweisen und auf eine Liste von <code class="language-plaintext highlighter-rouge">childNodes</code>. Im DOM ist <code class="language-plaintext highlighter-rouge">document</code> der Wurzelknoten, der lediglich eine Referenz auf <code class="language-plaintext highlighter-rouge">html</code> in seiner Kinderliste hat. <code class="language-plaintext highlighter-rouge">html</code> referenziert über die Eigenschaft <code class="language-plaintext highlighter-rouge">parentNode</code> das <code class="language-plaintext highlighter-rouge">document</code> und hat in seiner Kinderliste Referenzen auf <code class="language-plaintext highlighter-rouge">head</code> und <code class="language-plaintext highlighter-rouge">body</code>. <code class="language-plaintext highlighter-rouge">body</code> wiederum referenziert <code class="language-plaintext highlighter-rouge">html</code> als Mutter bzw Vater und hat wieder verschiedene Kindreferenzen, je nach Inhalt der darzustellenden Seite. Damit ergibt sich eine Baumstruktur, die sich in der Tiefe immer weiter verästeln kann und mit Hilfe der Entwicklertools, wie oben bereits getan, leicht einsehen lässt.</p>

<blockquote>
  <p>Wählen Sie sich für ein besseres Verständnis des DOM aus Ihren eigenen vorangegangenen Arbeiten eine Seite aus und stellen Sie deren DOM grafisch dar.</p>
</blockquote>

<h4 id="dom-elemente-in-ts-ansprechen">DOM Elemente in TS ansprechen</h4>

<p>Um ein HTMLElement in TS nutzen zu können, muss dieses zunächst aus dem Dokument herausgefunden werden. Das <code class="language-plaintext highlighter-rouge">document</code> ist ein globales Attribut des Browserfensters in dem unser Code ausgeführt wird.</p>

<p>Einige Elemente, welche pro Dokument nur einmal existieren, können direkt herausgezogen werden:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">head</span><span class="p">:</span> <span class="nx">HTMLHeadElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">body</span><span class="p">:</span> <span class="nx">HTMLElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span>
</code></pre></div></div>

<p>Andere Elemente können durch diverse Selektoren herausgefiltert werden.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ein (das erste) HTMLElement mit einer bestimmten id</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">uniqueIdName</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// alle HTMLElemente als Liste mit einem Klasennamen</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByClassName</span><span class="p">(</span><span class="dl">"</span><span class="s2">className</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// alle HTMLElemente als Liste eines Typs (hier HTMLDivElemente)</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTag</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// das erste HTMLElement, das dem Selektor entspricht </span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">.class &gt; div.divClass</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// alle HTMLElemente als Liste, die dem Selektor entsprechen </span>
<span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="dl">"</span><span class="s2">.class &gt; div.divClass</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>Der Queryselektor nutzt dabei die selbe Struktur wie CSS Definitionen.</p>

<p>Sobald die Elemente dann in einer Variablen gespeichert sind, können über deren Attribute und Methoden die Elemente verändert werden.</p>

<h5 id="elemente-erschaffen">Elemente erschaffen</h5>

<p>Um neue Elemente zu erschaffen, gibt es zwei Möglichkeiten.</p>

<p><strong>Die einfache aber gefährliche Variante</strong></p>

<p>Man kann über das <code class="language-plaintext highlighter-rouge">.innerHTML</code> Attribut die Textuelle Darstellung des HTMLs innerhalb des ausgewählten Elementes einfach mit einem String befüllen, welcher dann vom Browser analysiert und umgewandelt wird.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">`&lt;p&gt;Ein neuer Paragraph an dieser Stelle.&lt;/p&gt;`</span><span class="p">;</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="s2">`&lt;p&gt;Und noch einer dahinter.&lt;/p&gt;`</span><span class="p">;</span>
</code></pre></div></div>

<p>Gefährlich ist diese Methode, weil man so schnell vorherige Inhalte überschrieben hat. Außerdem werden bei jeder Änderung des <code class="language-plaintext highlighter-rouge">innerHTML</code>s immer alle Elemente aus dem DOM entfernt und das gesamte innerHTML neu interpretiert und aufgebaut. Dies ist nicht nur langsam, sondern löscht auch sämtliche Eventlistener welche an diesen Elementen angebracht waren. Zusätzlich ist das Anbringen solcher Listener umständlich.</p>

<p><strong>Die aufwändigere aber sichere Variante</strong></p>

<p>Über <code class="language-plaintext highlighter-rouge">document.createElement("typ")</code> lassen sich HTMLElemente auch programmatisch erzeugen. Diese können dann über ihre Attribute befüllt werden, über Methoden wie <code class="language-plaintext highlighter-rouge">.appendChild()</code> an andere Knoten angehängt werden, usw. Diese Vorgehensweise ist weitaus verboser als die oben gezeigte, umgeht dafür aber all ihre Probleme.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">p1</span><span class="p">:</span> <span class="nx">HTMLParagraphElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">p1</span><span class="p">.</span><span class="nx">innerText</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ein neuer Paragraph an dieser Stelle.</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">p1</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>Die Nutzung von <code class="language-plaintext highlighter-rouge">innerText</code> hat ähnliche Probleme wie <code class="language-plaintext highlighter-rouge">innerHTML</code>. Darum wäre es besser an dieser Stelle eine neue TextNode zu erschaffen.</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">p1</span><span class="p">:</span> <span class="nx">HTMLParagraphElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">p1</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">Ein neuer Paragraph an dieser Stelle.</span><span class="dl">"</span><span class="p">));</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">p1</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="typassertion">Typassertion</h5>

<blockquote>
  <p>Oder auch “Lieber Typescript Compiler, ich bin mir sicher bei dem was ich hier tue”.</p>
</blockquote>

<p>Wie in der letzten Woche unter dem Stichwort <a href="../L2.2/index.html#polymorphie">Polymorphie</a> bereits erklärt, können Instanzen von Subklassen auch in Variablencontainer ihrer Superklasse gespeichert werden.</p>

<p>So können z.B. auch <code class="language-plaintext highlighter-rouge">HTMLInputElement</code>e in <code class="language-plaintext highlighter-rouge">HTMLElement</code>en oder sogar <code class="language-plaintext highlighter-rouge">EventTarget</code>s gespeichert werden. Versucht man dann allerdings, auf die Subklassenspezifischen Attribute zuzugreifen, wird Typescript sich beschweren.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"email"</span> <span class="na">name=</span><span class="s">"email"</span> <span class="na">id=</span><span class="s">"emailInput"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Direkt als HTMLInputElement deklarieren </span>
<span class="kd">let</span> <span class="nx">input</span><span class="p">:</span> <span class="nx">HTMLInputElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">emailInput</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// ERROR: Type HTMLElement is not assignable to HTMLInputElement</span>

<span class="c1">// als HTMLElement deklarieren aber auf eine Input spezifisches Attribut zugreifen wollen</span>
<span class="kd">let</span> <span class="nx">input</span><span class="p">:</span> <span class="nx">HTMLElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">emailInput</span><span class="dl">"</span><span class="p">);</span> <span class="c1">//Kein Error</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="kd">type</span><span class="p">);</span>  <span class="c1">// ERROR: Property "type" does not exist on type "HTMLElement"</span>
</code></pre></div></div>

<p>Dises Problem kann umgangen werden, indem man dem Compiler mitteilt, dass man sich sicher ist, um welche Art von Subklasse es sich handelt, indem man diese in spitze Klammern <code class="language-plaintext highlighter-rouge">&lt;&gt;</code> vor das zu assertierende Objekt schreibt.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">input</span><span class="p">:</span> <span class="nx">HTMLInputElement</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">HTMLInputElement</span><span class="o">&gt;</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">textinput</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="kd">type</span><span class="p">);</span> <span class="c1">// "email"</span>
</code></pre></div></div>

<p>So kann nicht nur der Compiler ruhig gestellt werden, sondern es kann auch die eigene Arbeit erleichtern, da mit der richtigen Typisierung auch mehr/bessere/korrekte Vervollständigungsoptionen in VSCode angezeigt werden.</p>

<blockquote>
  <p>Dies sollte nur genutzt werden, wenn Sie sich sicher sind, welchen Typen Sie zurück bekommen. Alternativ (und sicherer für die Produktion außerhalb dieser Veranstaltung) wäre eine Prüfung mit <a href="../L2.2/index.html#instanceof"><code class="language-plaintext highlighter-rouge">instanceof</code></a>.</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">input</span><span class="p">:</span> <span class="nx">HTMLElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">textinput</span><span class="dl">"</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="nx">input</span> <span class="k">instanceof</span> <span class="nx">HTMLInputElement</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="kd">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// oder auch so</span>
<span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">input</span><span class="p">:</span> <span class="nx">HTMLElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">textinput</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">input</span> <span class="k">instanceof</span> <span class="nx">HTMLInputElement</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="kd">type</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="dom-untersuchen">DOM Untersuchen</h4>

<p>Sie können das DOM untersuchen und sich dessen Eigenschaften ausgeben lassen:</p>

<h5 id="dom-in-chrome-untersuchen">DOM in Chrome untersuchen</h5>

<p><img src="Chrome_DOM_Properties.png" alt="Dom in Chrome untersuchen" /></p>

<h5 id="dom-in-firefox-untersuchen">DOM in Firefox untersuchen</h5>

<p><img src="Firefox_DOM_Properties_1.png" alt="DOM in Firefox untersuchen" />
<img src="Firefox_DOM_Properties_2.png" alt="DOM in Firefox untersuchen" />
<img src="Firefox_DOM_Properties_3.png" alt="DOM in Firefox untersuchen" />
<img src="Firefox_DOM_Properties_4.png" alt="DOM in Firefox untersuchen" /></p>

<h4 id="daten-in-dom-elementen-speichern">Daten in DOM Elementen speichern</h4>

<p>DOM Elemente sind durch die DOM Klassenhierarchie klar definiert, und während JS zwar jegliche Modifikation von allen JS Objekten erlaubt, so ist das weder guter Stil noch in TS erlaubt.<br />
Man könnte nun überlegen, da manche Eigenschaften wie die Attribute nicht geprüft werden, eigene Attribute zu setzen. Und während das funktioniert, so ist es doch wieder nur ein Hack. Der offizelle Weg ist die Nutzung von <code class="language-plaintext highlighter-rouge">dataset</code>.</p>

<p><code class="language-plaintext highlighter-rouge">HTMLElement.dataset</code> ist ein Assoziatives Array und erlaubt es so, beliebige Key-Value Paare (strings) auf einem Element zu speichern.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">el</span><span class="p">:</span> <span class="nx">HTMLElement</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">#myElement</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">el</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Max Mustermann</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// "Max Mustermann"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">dataset</span><span class="p">[</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">])</span> <span class="c1">// "Max Mustermann"</span>
</code></pre></div></div>

<p>Die so hinzugefügten Daten werden im Inspektor als <code class="language-plaintext highlighter-rouge">data-&lt;key&gt;=&lt;value&gt;</code> angezeigt.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"myElement"</span> <span class="na">data-name=</span><span class="s">"Max Mustermann"</span><span class="nt">&gt;&lt;/div&gt;</span>
</code></pre></div></div>

<h3 id="ereignisse">Ereignisse</h3>
<p>Das DOM bietet zudem ein System für die Interaktion mit dem Nutzer: das Eventsystem. Es stellt äußerst bequem Informationen zu Ereignissen innerhalb der Anwendung zur Verfügung, ohne dass Kenntnisse der Hardware erforderlich sind. Das Betriebssystem und der Browser werten diese Ereignisse bereits aus und bringen die Informationen darüber in eine allgemeine Form.</p>

<h4 id="event-objekt">Event-Objekt</h4>
<p>Events sind spezielle Objekte, die Informationen über ein Ereignis
tragen. Ein solches Ereignis kann ein Mausklick sein, ein Tastendruck, eine Berührung des Bildschirms, das Laden einer Datei oder die Beendigung einer Datenübertragung und vieles mehr.</p>
<blockquote>
  <p>Im DOM-Klassendiagram sind einige Ereignisklassen aufgeführt. Finden Sie sie und heraus, welche Informationen diese tragen.</p>
</blockquote>

<h4 id="kurze-zusammenfassung-von-events">Kurze Zusammenfassung von Events:</h4>
<video controls="" width="100%"> 
    <source src="https://lehre.gabriel-rausch.de/HFU/EIA1_static/L06/L06_03_Events.mp4" type="video/mp4" /> 
    <a href="https://lehre.gabriel-rausch.de/HFU/EIA1_static/L06/L06_03_Events.mp4">Zum Video</a>
</video>

<h4 id="target">Target</h4>
<p>In der Regel bezieht sich ein Ereignis auf ein bestimmtes Objekt. Zum Beispiel auf den Button, der angeklickt wurde, den Link, der berührt wurde, das Fenster, das den Ladevorgang abgeschlossen hat oder das Textfeld, das verändert wurde. Die Eigenschaft <code class="language-plaintext highlighter-rouge">target</code> des Event-Objektes stellt eine Referenz auf dieses Ziel-Objekt zur Verfügung.</p>
<blockquote>
  <p>Von welchem Typ ist <code class="language-plaintext highlighter-rouge">target</code>? schauen Sie im Klassendiagramm.<br />
Objekte welcher Klassen / welches Typs können also <code class="language-plaintext highlighter-rouge">target</code>s sein?</p>
</blockquote>

<h4 id="type">Type</h4>
<p><code class="language-plaintext highlighter-rouge">type</code> ist eine simple Zeichenkette und gibt an, was für ein Ereignis beschrieben wird. Hier sind beispielsweise die Werte <code class="language-plaintext highlighter-rouge">click</code>, <code class="language-plaintext highlighter-rouge">load</code>, <code class="language-plaintext highlighter-rouge">change</code>, <code class="language-plaintext highlighter-rouge">dragstart</code> und viele weitere vordefiniert. Es ist aber auch möglich eigene, neue Ereignisse zu definieren.</p>
<blockquote>
  <ul>
    <li>Recherchieren Sie mehr. Finden Sie heraus, welche Arten von Events der Browser zur Verfügung stellt!</li>
  </ul>
</blockquote>

<h3 id="event-handler">Event-Handler</h3>
<p>Handler sind Funktionen, die ein Ereignis auswerten. Der Umgang damit ist denkbar simpel.</p>

<h4 id="handler-implementation">Handler-Implementation</h4>
<p>Um ein Ereignis auszuwerten, implementieren Sie einfach eine Funktion, deren Signatur diesem Muster entspricht:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handlerName</span><span class="p">(</span><span class="nx">_event</span><span class="p">:</span> <span class="nx">Event</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Die Funktion nimmt also einen Parameter vom Typ <code class="language-plaintext highlighter-rouge">Event</code> entgegen, im Beispiel trägt dieser Parameter den Namen <code class="language-plaintext highlighter-rouge">_event</code>. Auch der Name der Funktion ist frei wählbar, es ist aber zu empfehlen den Prefix “handle” oder abgekürzt “hnd” zu verwenden, z.B. “handleClick”, denn eine solche Funktion, die ein Event verarbeitet, nennt man Handler.</p>

<h4 id="listener-installation">Listener-Installation</h4>
<p>Damit das System weiß, bei welchem Ereignis welcher Handler aufgerufen werden soll, muss der Handler registriert werden. Dies erfolgt mit der Anweisung <code class="language-plaintext highlighter-rouge">addEventListener(...)</code>, zum Beispiel so:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="nx">handleClick</span><span class="p">);</span>
</code></pre></div></div>
<p>Der erste Parameter ist lediglich die Zeichenkette, die den Typ des Ereignisses beschreibt, der zweite eine Referenz zum Handler. Erhält das document-Objekt nun ein Event-Objekt vom Typ “click”, wird dieses an die Handler-Funktion <code class="language-plaintext highlighter-rouge">handleClick</code> weitergeschickt. Das <code class="language-plaintext highlighter-rouge">document</code>-Objekt horcht also jetzt in das System hinein, es wurde ihm hierfür ein “Ohr” installiert, ein sogenannter Listener.</p>
<blockquote>
  <p><strong>Achtung:</strong> Ein häufiger Fehler in Javascript ist, statt der Referenz einen Funktionsaufruf zu implementieren, z.B. mit <code class="language-plaintext highlighter-rouge">addEventListener("click", handleClick())</code>. Die zusätzliche Klammer bewirkt, dass die Funktion bereits bei der Installation aufgerufen wird und deren zurückgeliefertes Ergebnis als Handler-Referenz installiert wird.</p>
</blockquote>

<p>Oftmals findet man auch die folgende Schreibweise, gerade wenn man auf ältere Lösungen stößt:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">initPage</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="nx">handleClick</span><span class="p">;</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="nx">handleClick</span><span class="p">;</span>
</code></pre></div></div>
<p>Diese Vorgehensweise ist effektiv das Gleiche wie das Attribut im HTML zu setzen.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1</span> <span class="na">onclick=</span><span class="s">"myFunction()"</span><span class="nt">&gt;</span>Lorem Ipsum<span class="nt">&lt;/h1&gt;</span>
</code></pre></div></div>

<p>Diese Vorgehensweise ist aber <strong>veraltet</strong> und sollte darum <strong>nicht mehr verwendet werden!</strong> Sie hat gegenüber der neuen Methodik unter anderem den besonders wichtigen, klaren Nachteil, dass immer nur ein Listener jedem Objekt angeheftet werden kann und wenn ein anderer angehängt wird, wird der alte automatisch weggeworfen.</p>

<p>Wenn Sie in der Situation sind, dass Sie elementabhängige Übergabeparameter an die Funktion übergeben wollen, gibt es zwei schöne Möglichkeiten, dies mit der neuen Syntax zu lösen:</p>

<ol>
  <li>Die Daten über <code class="language-plaintext highlighter-rouge">dataset</code> statt in den Funktionsaufruf direkt aufs HTML Element speichern und dann in der Funktion auslesen, siehe <a href="#daten-in-dom-elementen-speichern">Daten in DOM Elementen speichern</a>.</li>
  <li>Sich die Geltungsbereiche bzw den gespeicherten Kontext von JS zunutze machen, indem man die aufzurufende Funktion innerhalb der Kontextes (z.B. innerhalb der for-Schleife welche die Elemente generiert o.ä.) definiert. Komplizierter zu verstehen aber in vielerlei Hinsicht interessanter, auch weil es allgemein sehr mächtig ist. Siehe <a href="../L2.1/index.html#scopes--geltungsbereiche">Scopes und Geltungsbereiche</a>, Abschnitt “Weiterführende Informationen”.</li>
</ol>

<h5 id="beispiel">Beispiel</h5>
<p>Das Folgende dürfte das wohl primitivste Beispiel sein, dass wir mit dem Eventsystem darstellen können. Eventuell müssen Sie zum Testen dieses Codes das <code class="language-plaintext highlighter-rouge">defer</code> Attribut des script tags weglassen.</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nx">L2_3_Load</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">load</span><span class="dl">"</span><span class="p">,</span> <span class="nx">handleLoad</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">handleLoad</span><span class="p">(</span><span class="nx">_event</span><span class="p">:</span> <span class="nx">Event</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_event</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Hiermit wird das <code class="language-plaintext highlighter-rouge">window</code>-Objekt, welches dem Browsertab entspricht in dem die Applikation läuft, angewiesen, die Funktion handleLoad aufzurufen, wenn ein “load”-Event ankommt, und ihr das zugehörige <code class="language-plaintext highlighter-rouge">event</code>-Objekt zu übergeben. <code class="language-plaintext highlighter-rouge">handleLoad</code> sorgt dann lediglich für die Darstellung des Objektes in der Konsole.</p>
<blockquote>
  <ul>
    <li>Untersuchen Sie das ausgegebene <code class="language-plaintext highlighter-rouge">event</code>-Objekt</li>
    <li>Recherchieren Sie nach dem <code class="language-plaintext highlighter-rouge">load</code>-Event, wann genau wird es ausgelöst? Was ist der Unterschied zu <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code> und dem <code class="language-plaintext highlighter-rouge">defer</code> Attribut für script tags?</li>
    <li>Installieren Sie den Listener am <code class="language-plaintext highlighter-rouge">document</code>-Objekt, statt am <code class="language-plaintext highlighter-rouge">window</code>-Objekt. Was geschieht nun?</li>
    <li>Experimentieren Sie in der gleichen Form mit <code class="language-plaintext highlighter-rouge">DOMContentLoaded</code>, wie verhält sich das System nun?</li>
  </ul>
</blockquote>

<h3 id="event-phasen">Event-Phasen</h3>
<p>Nicht alle Ereignisse werden allen Objekten im System mitgeteilt. Es ist also nur sinnvoll dort Listener zu installieren, wo sie auch wirken können. Besonders interessant wird das Ganze bei Nutzerinteraktionen, die auf DOM-Objekten ausgeführt werden, wie beispielsweise der Klick auf einen Button. Solche Ereignisse werden nämlich in drei Phasen durch den DOM-Graphen durchgereicht.</p>

<h4 id="phase-1-capture">Phase 1: Capture</h4>
<p>Das Event-Objekt wird zunächst an das <code class="language-plaintext highlighter-rouge">window</code> übergeben. Von dort wandert es zum <code class="language-plaintext highlighter-rouge">document</code>, zum <code class="language-plaintext highlighter-rouge">html</code>, zum <code class="language-plaintext highlighter-rouge">body</code> und weiter in den Baum in Richtung des <code class="language-plaintext highlighter-rouge">target</code>.</p>
<h4 id="phase-2-target">Phase 2: Target</h4>
<p>Wenn es vom Elternobjekt zum <code class="language-plaintext highlighter-rouge">target</code> gereicht wird, befindet sich das Event-Objekt in der Target-Phase.</p>
<h4 id="phase-3-bubble">Phase 3: Bubble</h4>
<p>Schließlich steigt das Event-Objekt im Baum wieder auf, bis es erneut das <code class="language-plaintext highlighter-rouge">window</code> erreicht. Es steigt also wie eine Luftblase unter Wasser an die Oberfläche.</p>

<h4 id="listener-options">Listener-Options</h4>
<p>Bei der Installation des Listeners können mit einem dritten Parameter noch Informationen zur Funktionsweise mitgegeben werden. Wird hier schlicht ein <code class="language-plaintext highlighter-rouge">true</code> mitgegeben, reagiert der Listener auf die Capture-Phase. Ansonsten, was üblicher ist, auf die Bubble-Phase. In jedem Fall reagiert er auf die Target-Phase.</p>

<h4 id="currenttarget">CurrentTarget</h4>
<p>Neben dem <code class="language-plaintext highlighter-rouge">target</code> trägt das Event-Objekt auch noch eine Referenz auf das Objekt, dessen Listener das Ereignis als letztes gehört hat. Mit <code class="language-plaintext highlighter-rouge">currentTarget</code> kann also ausgewertet werden, wo sich das Ereignis gerade im DOM befindet und bearbeitet wird.</p>

<h4 id="path">Path</h4>
<p>Den kompletten Pfad, den das Event durch das DOM nimmt, kann man im Attribut <code class="language-plaintext highlighter-rouge">path</code> einsehen oder per Skript durch die Methode <code class="language-plaintext highlighter-rouge">composedPath()</code> ermitteln.</p>

<h4 id="beispiel-1">Beispiel</h4>
<blockquote>
  <ul>
    <li>Untersuchen Sie die Seite <a href="https://jirkadelloro.github.io/EIA2-Inverted/X00_Code/L02_Events/Phases/">Phases</a> und lassen Sie den Code laufen.</li>
    <li>Was geschieht bei einem Klick auf den Button, bei einem Klick rechts daneben und bei einem Klick darunter? Warum?</li>
  </ul>
</blockquote>

<h3 id="takeaways">Takeaways</h3>

<p>Sie haben gelernt:</p>

<ul>
  <li>Wie Events in TypeScript funktionieren</li>
  <li>Wie die Phasen von Events verlaufen</li>
  <li>Wie Events registriert werden können</li>
  <li>Wie Eventhandling funktioniert</li>
  <li>Wie die DOM Klassenhierarchie aufgebaut ist</li>
  <li>Wie DOM Elemente selektiert und manipuliert werden können</li>
  <li>Wie DOM und Events zusammenhängen</li>
</ul>

<h3 id="typescript-dokumentation">Typescript Dokumentation</h3>

<p>https://www.typescriptlang.org/</p>

<hr />

<h2 id="-fragen-und-antworten"><strong>?!</strong> Fragen und Antworten</h2>

<p>(die Publikation der Zusammenfassung erfolgt nach dem Q&amp;A-Termin)</p>

<p>Zusammenfassung von: <a href="https://github.com/">&lt;Nutzername&gt;</a></p>

    <footer class="site-footer">
      <em><a href="../../index.html">Über diesen Kurs</a></em>
      <em><a href="../index.html">Lehrinhalte</a></em>
    </footer>
  </main>
</body>


<!-- Mirrored from hs-furtwangen.github.io/GIS-WiSe-2020-2021/content/L2.3/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 04 Dec 2020 16:50:31 GMT -->
</html>
