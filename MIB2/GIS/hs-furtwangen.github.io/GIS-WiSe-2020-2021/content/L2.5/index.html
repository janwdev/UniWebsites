<!DOCTYPE html>
<html lang="en-US">


<!-- Mirrored from hs-furtwangen.github.io/GIS-WiSe-2020-2021/content/L2.5/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 04 Dec 2020 16:50:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="stylesheet" href="../../assets/css/styleb6a9.css?v=ea27abaf339b85bc83f8e9f02e46150f2ace2c25">
  <link rel="shortcut icon" type="image/x-icon" href="../../assets/faviconb6a9.ico?v=ea27abaf339b85bc83f8e9f02e46150f2ace2c25">
  <title>Grundlage interaktiver Systeme - Wintersemester 2020/2021</title>
</head>

<body>
  <header class="page-header" role="banner">
    <div class="page-header-inner main-content">
      <div class="logo-wrapper">
        <div class="logo"></div>
      </div>
      <h1 class="project-name"><a href="../../index.html">Grundlagen interaktiver Systeme</a></h1>
      <h2 class="project-tagline">für MIB und OMB – WiSe 2020/2021</h2>
      <em><a href="../index.html#1-html-und-css"><strong>1</strong> HTML und CSS</a></em>
      <em><a href="../index.html#2-typescript"><strong>2</strong> TypeScript</a></em>
      <em><a href="../index.html#3-server-und-datenbanken"><strong>3</strong> Server und Datenbanken</a></em>
    </div>
  </header>
  <main id="content" class="main-content content-wrapper" role="main">
    <h2 id="v-25-kommunikation"><em>V</em> <strong>2.5</strong> Kommunikation</h2>

<h3 id="inhaltsverzeichnis">Inhaltsverzeichnis</h3>

<ul>
  <li><a href="#kommunikation">Kommunikation</a>
    <ul>
      <li><a href="#synchron">Synchron</a></li>
      <li><a href="#asynchron">Asynchron</a></li>
    </ul>
  </li>
  <li><a href="#implementation-asynchroner-kommunikation">Implementation asynchroner Kommunikation</a>
    <ul>
      <li><a href="#xmlhttprequest-events">XMLHttpRequest-Events</a></li>
      <li><a href="#fetch-und-promises">Fetch und Promises</a></li>
      <li><a href="#asyncawait">Async/Await</a></li>
    </ul>
  </li>
  <li><a href="#-fragen-und-antworten">Q&amp;A</a></li>
</ul>

<h2 id="kommunikation">Kommunikation</h2>
<p>Kommunikation ist der Prozess des Austauschs oder der Übertragung von Information. Dabei werden zwei grundsätzliche Formen derselben unterschieden.</p>

<h3 id="synchron">Synchron</h3>
<p><img src="Synchron.svg" alt="" /></p>

<p>Synchron bedeutet “zeitlich gemeinsam”. Bei der Kommunikation heißt das allerdings nicht gleichzeitig, sondern “aufeinander abgestimmt”. Das bedeutet, dass die Kommunikationspartner aufeinander warten, bis der jeweils andere seine Information übertragen hat und dann ihrerseits mit einer Übertragung beginnen. Das bedeutet zwangsläufig, dass die beteiligten Systeme die Hälfte der zur Verfügung stehenden Zeit mit Warten verbringen. Im Diagram, welches den Kommunikationsalgorithmus eines der Partner darstellt, wird dies mit der kleinen Schleife angedeutet.</p>

<blockquote>
  <ul>
    <li>Sammle Beispiele für synchrone Kommunikation in deinem eigenen Alltag.</li>
  </ul>
</blockquote>

<p>So klein diese Schleife auch erscheint, sie kann ein großes Problem darstellen. Die Systeme könnten die Wartezeiten sinnvoll nutzen, anstatt nur in Ihnen zu verharren. Besonders problematisch wird es, wenn ein System für die Antwort lange braucht. Wenn beispielsweise eine Webseite nicht mehr reagiert, weil der Browser auf eine Antwort des Servers wartet, wird der Nutzer den Prozess bald abbrechen. <strong>Darum sollte synchrone Kommunikation in der Implementierung, besonders bei Systemen, welche ein bemerkbare Ladezeit haben, vermieden werden, um ein Blockieren des Systems zu verhindern.</strong></p>

<h3 id="asynchron">Asynchron</h3>

<p><img src="Asynchron.svg" alt="" /><br />
Daher hat sich die asynchrone Kommunikation durchgesetzt. Die Kommunikationspartner setzen eine oder mehrere Anfragen ab, damit ist ihr Teil zunächst erledigt und sie können sich um andere Aufgaben kümmern. Irgendwann kommt ein Signal, dass eine Antwort auf eine der Anfragen vorliegt. Dieses dient als Startpunkt für einen neuen Prozess, bei dem zunächst die Antwort verarbeitet wird und gegebenenfalls weitere Anfragen verschickt werden.</p>

<blockquote>
  <ul>
    <li>Sammle Beispiele für asynchrone Kommunikation in deinem eigenen Alltag.</li>
    <li>Was sind die besonderen Herausforderungen bei der asynchronen Kommunikation?</li>
  </ul>
</blockquote>

<p>Damit ist es Webseiten beispielsweise möglich, die Darstellung aufzubauen und Interaktion zur Verfügung zu stellen, während weitere Daten geladen werden. Oder während der Interaktion mit dem Nutzer Daten zu versenden.</p>

<h2 id="implementation-asynchroner-kommunikation">Implementation asynchroner Kommunikation</h2>

<h3 id="xmlhttprequest-events">XmlHttpRequest-Events</h3>
<p>Bei der asynchronen Kommunikation lässt sich wieder sehr gut die Ereignissteuerung einsetzen. Javascript bietet hierzu das Standardobjekt / die Standardklasse <code class="language-plaintext highlighter-rouge">XMLHttpRequest</code> an. Ein solches Objekt kann mit dem Schlüsselwort <code class="language-plaintext highlighter-rouge">new</code> erzeugt werden. Die Klasse bietet einige Methoden, mit denen recht einfach eine Verbindung zu einem Server aufgebaut und eine Anfrage verschickt werden kann. Während das Objekt die Verbindung verwaltet, erzeugt es bei Statusänderungen entsprechende Events, die wiederum mit dem üblichen Schema von Listeners abgefangen und an die zugehörigen Handlerfunktionen weitergeleitet werden. Auch die vollständige Übertragung der Serverantwort ist eine solche Statusänderung, womit dann die Clientseite einer Server-Client Kommunikation abgebildet werden kann.</p>
<blockquote>
  <p>Das XML im Namen des Objektes verrät, dass es sich dabei um eine <strong>etwas betagte Technologie</strong> handelt, die 1999, während der Standardisierung von HTML4, von Microsoft veröffentlicht wurde. Sie ist aber weit verbreitet und kommt noch häufig zum Einsatz. <a href="https://wiki.selfhtml.org/wiki/JavaScript/XMLHttpRequest">Mehr Infos gibt es hier.</a></p>
</blockquote>

<h3 id="fetch-und-promises">Fetch und Promises</h3>

<p>2017 wurde die globale Javascript-Funktion <code class="language-plaintext highlighter-rouge">fetch</code> als Schnittstelle für asynchrone Kommunikation eingeführt. So kann mit einer einzigen Anweisung nach dem Muster <code class="language-plaintext highlighter-rouge">fetch(url [, data])</code> eine Anfrage verschickt und eine Antwort erhalten werden. Aufgrund der Asynchronität liefert fetch aber nicht sofort die Antwort des Servers, sondern ein Objekt vom Typ <code class="language-plaintext highlighter-rouge">Promise</code>. Dies kann metaphorisch betrachtet werden: Das Versprechen, das fetch abgibt, verpflichtet dazu, die eigentliche Funktion auszuführen, in diesem Falle also zu kommunizieren, und im Erfolgsfall, sowie im Falle des Misserfolgs, bestimmte weitere Funktionen aufzurufen. Es handelt sich also wieder um eine Ereignissteuerung, die aber in einem etwas anderen Gewand daherkommt.</p>

<p>Im einfachsten Fall sieht das ganze Konstrukt dann so aus:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">communicate</span><span class="p">(</span><span class="nx">_url</span><span class="p">:</span> <span class="nx">RequestInfo</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="c1">// try to communicate</span>
  <span class="kd">let</span> <span class="na">promise</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Response</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">_url</span><span class="p">);</span>
  <span class="c1">// establish the functions to call when communications 1. succeeds, 2. fails</span>
  <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">handleSuccess</span><span class="p">,</span> <span class="nx">handleFailure</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">handleFailure</span><span class="p">(</span><span class="nx">_response</span><span class="p">:</span> <span class="nx">Response</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Failure</span><span class="dl">"</span><span class="p">,</span> <span class="nx">_response</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">handleSuccess</span><span class="p">(</span><span class="nx">_response</span><span class="p">:</span> <span class="nx">Response</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Success</span><span class="dl">"</span><span class="p">,</span> <span class="nx">_response</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Auch hier ist die Funktionalität über mehrere Funktionen verteilt und daher insgesamt etwas unübersichtlich. Das wird noch verstärkt dadurch, dass die Response, die den Handlern von der Promise als Parameter übergeben wird, noch nicht die Rohdaten der Antwort des Kommunikationspartners darstellt. Um die Response zu verarbeiten sind weitere Funktionen erforderlich, die wiederum Promises erzeugen, die weitere Handler aufrufen und so weiter.</p>
<blockquote>
  <p><strong>FunFact:</strong> Dadurch entsteht ein Gewirr an Funktionen, das von Entwicklern als “Callback Hell” bezeichnet wird.</p>
</blockquote>

<h3 id="asyncawait">Async/Await</h3>

<p>Deswegen wurden 2017 auch die neuen Schlüsselworte <code class="language-plaintext highlighter-rouge">async</code> und <code class="language-plaintext highlighter-rouge">await</code> in Javascript implementiert. Damit wird nun etwas ganz Erstaunliches möglich: Anstatt mit der synchronen Programmierweise (eine Anweisung im Code erfolgt strikt nach Beendigung der vorangegangenen) und Events asynchrone Prozesse abzubilden und damit “Callback Hell” zu erzeugen, wird mit Hilfe der beiden Schlüsselworte die Programmierung selbst asynchron. Damit wird das fetch-Beispiel plötzlich extrem übersichtlich:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">communicate</span><span class="p">(</span><span class="nx">_url</span><span class="p">:</span> <span class="nx">RequestInfo</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="na">response</span><span class="p">:</span> <span class="nx">Response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">_url</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Response</span><span class="dl">"</span><span class="p">,</span> <span class="nx">response</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Mit dem Schlüsselwort <code class="language-plaintext highlighter-rouge">async</code> wird eine Funktion als asynchron deklariert, das bedeutet, dass ihre Ausführung unterbrochen und zu einem späteren Zeitpunkt fortgesetzt werden kann. Genau dies bewirkt das Schlüsselwort <code class="language-plaintext highlighter-rouge">await</code>, welches daher nur innerhalb von asynchronen Funktionen Sinn ergibt. Sobald <code class="language-plaintext highlighter-rouge">fetch</code> gestartet wird, wird die Funktion <code class="language-plaintext highlighter-rouge">communicate</code> zunächst beendet und die Ausführung des Programms bei der nächsten Anweisung nach deren Aufruf fortgesetzt. Sobald aber <code class="language-plaintext highlighter-rouge">fetch</code> beendet wurde, wird die Funktion <code class="language-plaintext highlighter-rouge">communicate</code> bei der Anweisung nach dem fetch fortgesetzt. Das heißt also, dass das Hauptprogramm, sofern es noch nicht komplett abgelaufen ist, unterbrochen wird um die Ausgabe der Response in der Konsole zu bewerkstelligen. Danach ist <code class="language-plaintext highlighter-rouge">communicate</code> tatsächlich am Ende und das Hauptprogramm wird fortgesetzt. Es könnten aber in der Funktion noch weitere <code class="language-plaintext highlighter-rouge">await</code>s folgen, die wieder entsprechendes Verhalten bewirken. So bläht die weitere Verarbeitung der Response den Code nicht noch wieder durch Callbacks auf.</p>
<blockquote>
  <ul>
    <li>Kopieren Sie obenstehenden asynchronen Code und betten Sie ihn in ein neues Programm ein. Lassen Sie vom Hauptprogramm aus die Funktion <code class="language-plaintext highlighter-rouge">communicate</code> mit dem Parameter <code class="language-plaintext highlighter-rouge">"https://hs-furtwangen.github.io/GIS-WiSe-2020-2021/content/L2.5/test.txt"</code> aufrufen. Lassen Sie vor und nach dem Aufruf von <code class="language-plaintext highlighter-rouge">communicate</code> in der Konsole die Zeichenketten “Start” und “End” ausgeben.</li>
    <li>Starten Sie nun das Programm, nachdem Sie es lauffähig implementiert haben. Beschreiben Sie ihre Beobachtung. In welcher Reihenfolge kommen die Ausgaben in der Konsole?</li>
    <li>Das ausgegebene Response-Objekt ist komplex und der eigentliche Inhalt der Serverantwort ist noch nicht zu sehen. Erweitern Sie die Funktion <code class="language-plaintext highlighter-rouge">communicate</code> um eine Zeile, in der Sie die Methode <code class="language-plaintext highlighter-rouge">text()</code> des Response-Objektes aufrufen.<br />
Achtung: <code class="language-plaintext highlighter-rouge">text()</code> gibt wieder eine Promise zurück. Nutzen Sie aber auch hier <code class="language-plaintext highlighter-rouge">await</code>, erhalten Sie als Ergebnis des Ganzen eine Zeichenkette, die Sie einer Variablen vom Typ string zuweisen können. Lassen Sie so den Inhalt der Serverantwort ausgeben.</li>
    <li>Versuchen Sie das gleiche nochmal mit dem Parameter <code class="language-plaintext highlighter-rouge">"https://hs-furtwangen.github.io/GIS-WiSe-2020-2021/content/L2.5/testjson.json"</code> und der Funktion <code class="language-plaintext highlighter-rouge">json()</code> statt <code class="language-plaintext highlighter-rouge">text()</code>. Was wird hier zurückgegeben?</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Hinweis</strong>: fetch erwartet immer eine <code class="language-plaintext highlighter-rouge">http(s)://</code> Anfrage, wenn Sie es also lokal testen wollen, sollten Sie einen Live-Server verwenden, da sonst die Anfrage mit <code class="language-plaintext highlighter-rouge">file://</code> beginnt. Siehe auch den <a href="../L2.4/index.html#local-storage">Hinweise zu LocalStorage</a>.</p>
</blockquote>

<h3 id="typescript-dokumentation">Typescript Dokumentation</h3>

<p>https://www.typescriptlang.org/</p>

<hr />

<h2 id="-fragen-und-antworten"><strong>?!</strong> Fragen und Antworten</h2>

<p>(die Publikation der Zusammenfassung erfolgt nach dem Q&amp;A-Termin)</p>

<p>Zusammenfassung von: <a href="https://github.com/">&lt;username&gt;</a></p>


    <footer class="site-footer">
      <em><a href="../../index.html">Über diesen Kurs</a></em>
      <em><a href="../index.html">Lehrinhalte</a></em>
    </footer>
  </main>
</body>


<!-- Mirrored from hs-furtwangen.github.io/GIS-WiSe-2020-2021/content/L2.5/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 04 Dec 2020 16:50:32 GMT -->
</html>
